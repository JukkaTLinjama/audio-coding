<!doctype html>
<html lang="fi">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Fish School (Boids) â€“ v3.6</title>
  <style>
    html,
    body {
      margin: 0;
      height: 100%;
      overflow: hidden;
      background: #0b1020;
    }

    canvas {
      display: block;
    }

    /* Simple mobile HUD overlay */
    #hud {
      position: fixed;
      left: 12px;
      right: 12px;
      bottom: 12px;
      padding: 10px 12px;
      border-radius: 14px;
      background: rgba(0, 0, 0, 0.55);
      color: #fff;
      font: 14px/1.2 -apple-system, system-ui, sans-serif;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      user-select: none;
      touch-action: manipulation;
    }

    #hud .row {
      display: flex;
      align-items: center;
      gap: 10px;
      margin: 8px 0;
    }

    #hud label {
      width: 140px;
      opacity: 0.95;
    }

    #hud input[type=range] {
      flex: 1;
    }

    #hud span {
      width: 48px;
      text-align: right;
      opacity: 0.9;
    }

    #hud button {
      flex: 1;
      padding: 10px 12px;
      border: 0;
      border-radius: 12px;
      background: rgba(255, 255, 255, 0.14);
      color: #fff;
    }
  </style>
</head>

<body>
    <div id="hud">
      <div style="
        font-weight:600;
        font-size:15px;
        margin-bottom:8px;
        opacity:0.9;
      ">
        Fish School v3.6
      </div>

    <div class="row">
      <label>Solo independence</label>
      <input id="soloInd" type="range" min="0" max="1" step="0.01" value="0.70">
      <span id="soloIndVal">0.70</span>
    </div>
    <div class="row">
      <label>Density</label>
      <input id="density" type="range" min="0" max="1" step="0.01" value="0.55">
      <span id="densityVal">0.55</span>
    </div>
    <div class="row">
      <button id="scatter">Scatter 30%</button>
      <button id="regroup">Regroup</button>
    </div>
  </div>

  <script type="module">
    import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";

    // ---------- Utilities ----------
    const clamp = (x, a, b) => Math.max(a, Math.min(b, x));
    const lerp = (a, b, t) => a + (b - a) * t;

    function randomUnitVec3(out) {
      // Random direction on sphere
      const u = Math.random();
      const v = Math.random();
      const theta = 2 * Math.PI * u;
      const phi = Math.acos(2 * v - 1);
      out.set(
        Math.sin(phi) * Math.cos(theta),
        Math.sin(phi) * Math.sin(theta),
        Math.cos(phi)
      );
      return out;
    }

    function setMag(v, m) {
      const len = v.length();
      if (len > 1e-6) v.multiplyScalar(m / len);
      return v;
    }

    function clampLen(v, maxLen) {
      const len = v.length();
      if (len > maxLen && len > 1e-6) v.multiplyScalar(maxLen / len);
      return v;
    }

    // ---------- Scene ----------
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(Math.min(2, window.devicePixelRatio || 1));
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x0b1020, 8, 40);

    const camera = new THREE.PerspectiveCamera(
      50,
      window.innerWidth / window.innerHeight,
      0.1,
      200
    );

    // Camera straight on Z axis, looking at XY plane
    camera.position.set(0, 0, 22);
    camera.lookAt(0, 0, 0);

    const lightA = new THREE.HemisphereLight(0xffffff, 0x223355, 0.9);
    scene.add(lightA);

    const lightB = new THREE.DirectionalLight(0xffffff, 0.8);
    lightB.position.set(8, 18, 10);
    scene.add(lightB);

// Moving point lights for "living gloss" (no shadows)
const keyLight = new THREE.PointLight(0xffffff, 1.1, 80);
const fillLight = new THREE.PointLight(0x88ccff, 0.7, 80);
scene.add(keyLight);
scene.add(fillLight);

function animateLights(ms) {
  // Move lights in slow circles to create shifting highlights on the fish bodies
  const t = ms * 0.001;
  keyLight.position.set(Math.cos(t) * 12, 6, Math.sin(t) * 12);
  fillLight.position.set(Math.cos(t * 0.7) * -10, -4, Math.sin(t * 0.7) * 10);
}

    // Fish geometry: body + tail (rocket-like exhaust)
// Cone points +Y by default; we'll orient +Y = forward.
const bodyGeom = new THREE.ConeGeometry(0.25, 1.2, 8);
const tailGeom = new THREE.ConeGeometry(0.18, 0.45, 8);

// Move tail backward along -Y (rear of the fish)
tailGeom.translate(0, -0.8, 0);

// Materials: body color changes by mode; tail stays "exhaust" color
// Use StandardMaterial so lights create moving specular highlights (no shadows).
const bodyMat = new THREE.MeshStandardMaterial({
  color: 0xcfe9ff,
  roughness: 0.22,
  metalness: 0.05,
});

const tailMat = new THREE.MeshStandardMaterial({
  color: 0xffb36b,
  roughness: 0.45,
  metalness: 0.0,
  emissive: 0xff5a00,
  emissiveIntensity: 0.9,
});
const N = 30;
    const COLOR_SCHOOL = new THREE.Color("#cfe9ff");
    const COLOR_SOLO = new THREE.Color("#ff7a2f");

    // For N=30, separate objects are simplest and reliable on mobile.
// Each fish is a Group: [0]=body, [1]=tail.
const fishMeshes = [];
const fishBodies = [];
const fishTails = [];

for (let i = 0; i < N; i++) {
  const body = new THREE.Mesh(bodyGeom, bodyMat.clone());
  const tail = new THREE.Mesh(tailGeom, tailMat.clone());

  const fish = new THREE.Group();
  fish.add(body);
  fish.add(tail);

  scene.add(fish);
  fishMeshes.push(fish);
  fishBodies.push(body);
  fishTails.push(tail);
}

    // ---------- Simulation data (arrays) ----------
    const P = Array.from({ length: N }, () => new THREE.Vector3());
    const V = Array.from({ length: N }, () => new THREE.Vector3());

    // Acceleration-based visuals (tail thrust + banking)
    // English comments for open-source continuity.
    const Vprev = Array.from({ length: N }, () => new THREE.Vector3());
    const aForwardSm = new Float32Array(N); // signed forward acceleration (smoothed)
    const aLateralSm = new Float32Array(N); // signed lateral acceleration (smoothed)
    const noise = Array.from({ length: N }, () => new THREE.Vector3());
    const noiseTarget = Array.from({ length: N }, () => new THREE.Vector3());

    const isSolo = new Uint8Array(N);
    const flock = new Float32Array(N);
    const flockTarget = new Float32Array(N);

    // ---------- Parameters (tuned for calm fish school) ----------
    const params = {
      density: 0.55,
      soloIndependence: 0.70,

      // Base boids
      neighborRadius: 6.5,
      separationRadius: 1.6,
      wAlignment: 1.2,
      wCohesion: 1.1,
      wSeparation: 0.6,

      // Motion limits (calm)
      maxSpeed: 1.9,   // units/s
      minSpeed: 1.2,   // units/s
      maxSteer: 1.6,   // units/s^2

      // Orbit around a circle in XY plane, with a little vertical thickness
      center: new THREE.Vector3(0, 0, 0),
      orbitRadius: 7.0,
      orbitSpeed: 1.55,
      radiusK: 0.35,

      // Noise (smoothed)
      noiseStrength: 0.55,
      noiseLerp: 0.03,

      // Thickness in Z (school is a ribbon / tube)
      zWanderK: 0.25, // gentle pull to z ~ 0
    };

    function soloFlockTarget(ind) {
      // 0 => behaves more like the school, 1 => mostly independent
      // Never go fully 0 to avoid "different species" vibe.
      return 0.9 - 0.7 * ind; // 0.2..0.9
    }

  function applyDensity() {
    // Stronger mapping so the slider is clearly visible in motion
    params.wCohesion = lerp(0.6, 2.0, params.density);
    params.wAlignment = lerp(0.8, 1.8, params.density);

    // World-units (since neighborR is now used directly)
    params.neighborRadius = lerp(8.0, 5.5, params.density);
  }

    function setMode(i, solo) {
      isSolo[i] = solo ? 1 : 0;

      // Update per-fish material color immediately
      fishBodies[i].material.color.copy(solo ? COLOR_SOLO : COLOR_SCHOOL);

      flockTarget[i] = solo ? soloFlockTarget(params.soloIndependence) : 1.0;
    }

    function applySoloIndependence() {
      const t = soloFlockTarget(params.soloIndependence);
      for (let i = 0; i < N; i++) flockTarget[i] = isSolo[i] ? t : 1.0;
    }

    function init() {
      // Spawn fish around the orbit ring with some noise
      for (let i = 0; i < N; i++) {
        const a = Math.random() * Math.PI * 2;
        const r = params.orbitRadius + (Math.random() - 0.5) * 1.5;

        P[i].set(
          Math.cos(a) * r,
          (Math.random() - 0.5) * 1.2,
          Math.sin(a) * 0.8
        );

        // Start tangential velocity + small jitter
        const tangent = new THREE.Vector3(-Math.sin(a), Math.cos(a), 0).normalize();
        V[i].copy(tangent).multiplyScalar(params.orbitSpeed);
        V[i].addScaledVector(randomUnitVec3(new THREE.Vector3()), 0.2);


        // Initialize acceleration history
        Vprev[i].copy(V[i]);
        aForwardSm[i] = 0;
        aLateralSm[i] = 0;
        noise[i].copy(randomUnitVec3(new THREE.Vector3()));
        noiseTarget[i].copy(randomUnitVec3(new THREE.Vector3()));

        flock[i] = 1.0;
        setMode(i, Math.random() < 0.25); // start with some solos
      }
    }

    // ---------- UI binding ----------
    function bindSlider(id, valId, onChange) {
      const el = document.getElementById(id);
      const out = document.getElementById(valId);
      const update = () => {
        const v = parseFloat(el.value);
        out.textContent = v.toFixed(2);
        onChange(v);
      };
      el.addEventListener("input", update, { passive: true });
      update();
    }

    bindSlider("soloInd", "soloIndVal", (v) => {
      params.soloIndependence = v;
      applySoloIndependence();
    });

    bindSlider("density", "densityVal", (v) => {
      params.density = v;
      applyDensity();
    });

    document.getElementById("scatter").addEventListener("click", () => {
      for (let i = 0; i < N; i++) {
        if (Math.random() < 0.30) setMode(i, true);
      }
    });

    document.getElementById("regroup").addEventListener("click", () => {
      for (let i = 0; i < N; i++) setMode(i, false);
    });

    // ---------- Simulation step ----------
    const tmp = {
      d: new THREE.Vector3(),
      sumPos: new THREE.Vector3(),
      sumVel: new THREE.Vector3(),
      sep: new THREE.Vector3(),
      desired: new THREE.Vector3(),
      steer: new THREE.Vector3(),
      r2: new THREE.Vector3(),
      tangent: new THREE.Vector3(),
      radial: new THREE.Vector3(),
      up: new THREE.Vector3(0, 1, 0),
      quat: new THREE.Quaternion(),
      m4: new THREE.Matrix4(),
      s: new THREE.Vector3(1, 1, 1),

      // Scratch vectors for acceleration decomposition
      a: new THREE.Vector3(),
      fwd: new THREE.Vector3(),
      right: new THREE.Vector3(),
      worldUp: new THREE.Vector3(0, 0, 1),
    };


    function updateNoise(i) {
      // Occasionally pick a new target; then smoothly approach it.
      if (Math.random() < 0.02) randomUnitVec3(noiseTarget[i]);
    }

    function step(dt) {
      // dt capped for stability (mobile frame drops)
      dt = Math.min(0.033, dt);

      const neighborR = params.neighborRadius;      // convert px-ish values to world-ish
      const separationR = params.separationRadius;
      // Blend flock factor smoothly (dt-stable exponential smoothing)
      const tau = 0.18;
      const aBlend = 1 - Math.exp(-dt / tau);

      for (let i = 0; i < N; i++) {
        flock[i] += (flockTarget[i] - flock[i]) * aBlend;

        // Smoothed noise (fish-like wander)
        updateNoise(i);
        noise[i].lerp(noiseTarget[i], params.noiseLerp);
      }
      // Global center to prevent the school splitting into multiple clusters
      const globalCenter = new THREE.Vector3();
      let globalCount = 0;
      for (let i = 0; i < N; i++) {
        if (isSolo[i]) continue; // keep solos freer
        globalCenter.add(P[i]);
        globalCount++;
      }
      if (globalCount > 0) globalCenter.multiplyScalar(1 / globalCount);

      for (let i = 0; i < N; i++) {
        const p = P[i];
        const v = V[i];

        tmp.sumPos.set(0, 0, 0);
        tmp.sumVel.set(0, 0, 0);
        tmp.sep.set(0, 0, 0);
        let count = 0;

        // O(N^2) neighbor scan (fine for N=30)
        for (let j = 0; j < N; j++) if (j !== i) {
          tmp.d.copy(P[j]).sub(p);
          const dist = tmp.d.length();

          if (dist < neighborR) {
            count++;
            tmp.sumPos.add(P[j]);
            tmp.sumVel.add(V[j]);

            if (dist < separationR && dist > 1e-6) {
              // Repel more strongly when very close
              tmp.sep.addScaledVector(tmp.d, -1 / (dist * dist));
            }
          }
        }

        // Build desired velocity (fishy: steer toward desiredVel, not raw force sum)
        tmp.desired.set(0, 0, 0);

        if (count > 0) {
          const inv = 1 / count;

          // Alignment direction
          tmp.sumVel.multiplyScalar(inv);
          if (tmp.sumVel.lengthSq() > 1e-8) tmp.sumVel.normalize();
          tmp.desired.addScaledVector(tmp.sumVel, params.wAlignment * flock[i]);

          // Cohesion direction (toward neighbors' center)
          tmp.sumPos.multiplyScalar(inv).sub(p);
          if (tmp.sumPos.lengthSq() > 1e-8) tmp.sumPos.normalize();
          tmp.desired.addScaledVector(tmp.sumPos, params.wCohesion * flock[i]);

          // Separation direction
          // Separation: keep magnitude (stronger when very close), but clamp to avoid instability
if (tmp.sep.lengthSq() > 1e-8) {
  clampLen(tmp.sep, 3.0); // max separation impulse (tune 1.5..6.0)
  tmp.desired.addScaledVector(tmp.sep, params.wSeparation);
}
}

        // Orbit field around a circle in XY plane
        tmp.r2.copy(p).sub(params.center);
        tmp.r2.z = 0;
        const rLen = tmp.r2.length() + 1e-6;

        tmp.tangent.set(-tmp.r2.y, tmp.r2.x, 0).normalize();
        tmp.desired.addScaledVector(tmp.tangent, params.orbitSpeed);
        // Keep solo fish moving with the main flow so they don't lag behind
        if (isSolo[i]) {
          tmp.desired.addScaledVector(tmp.tangent, 0.8); // tune 0.4..1.2
        }

        // Gentle radial correction toward orbitRadius
        const err = rLen - params.orbitRadius;
        tmp.radial.copy(tmp.r2).multiplyScalar(1 / rLen);
        tmp.desired.addScaledVector(tmp.radial, -err * params.radiusK);

        // Keep school fairly thin in Z (soft pull toward z=0)
        tmp.desired.z += (-p.z) * params.zWanderK;

        // Add smoothed noise
        tmp.desired.addScaledVector(noise[i], params.noiseStrength);
        // Mild "glue" towards global center so the school doesn't split into two flocks
        if (globalCount > 0) {
          const toGlobal = globalCenter.clone().sub(p);
          if (toGlobal.lengthSq() > 1e-8) {
            toGlobal.normalize();
            tmp.desired.addScaledVector(toGlobal, 0.35 * flock[i]);
          }
        }

        // Convert desired direction into target speed (cruise-like)
        const cruise = lerp(params.minSpeed, params.maxSpeed, 0.55);
        if (tmp.desired.lengthSq() > 1e-8) setMag(tmp.desired, cruise);

        // Steering = desiredVel - currentVel
        tmp.steer.copy(tmp.desired).sub(v);
        clampLen(tmp.steer, params.maxSteer);

        // Integrate
        v.addScaledVector(tmp.steer, dt);

        // Clamp speed
        const speed = v.length();
        if (speed > params.maxSpeed) v.multiplyScalar(params.maxSpeed / speed);
        else if (speed < params.minSpeed) v.multiplyScalar(params.minSpeed / speed);

        p.addScaledVector(v, dt);


        // --- Acceleration decomposition (for visuals) ---
        // a = (v - vPrev) / dt
        const invDt = 1 / Math.max(dt, 1e-4);
        tmp.a.copy(v).sub(Vprev[i]).multiplyScalar(invDt);

        // fwd axis from velocity
        tmp.fwd.copy(v);
        if (tmp.fwd.lengthSq() < 1e-8) tmp.fwd.set(0, 1, 0);
        tmp.fwd.normalize();

        // right axis = fwd x worldUp (screen-ish basis; XY is screen plane)
        tmp.right.copy(tmp.fwd).cross(tmp.worldUp);
        if (tmp.right.lengthSq() < 1e-8) {
          // Fallback if fwd || up
          tmp.worldUp.set(0, 1, 0);
          tmp.right.copy(tmp.fwd).cross(tmp.worldUp);
          tmp.worldUp.set(0, 0, 1);
        }
        tmp.right.normalize();

        // Signed forward and lateral acceleration components
        const aForward = tmp.a.dot(tmp.fwd);
        const aLateral = tmp.a.dot(tmp.right);

        // Smooth to avoid flicker
        const alphaAcc = 1 - Math.exp(-dt / 0.10); // ~100ms response
        aForwardSm[i] += (aForward - aForwardSm[i]) * alphaAcc;
        aLateralSm[i] += (aLateral - aLateralSm[i]) * alphaAcc;

        // Store v for next frame
        Vprev[i].copy(v);
        // Soft bounds (keep them near center, like "invisible aquarium")
        // This is intentionally gentle to keep things calm.
        const maxR = params.orbitRadius * 1.9;
        const r3 = p.clone().sub(params.center);
        const r3Len = r3.length();
        if (r3Len > maxR) {
          r3.multiplyScalar(1 / (r3Len + 1e-6));
          p.addScaledVector(r3, -(r3Len - maxR) * 0.12);
        }
      }
    }

    // ---------- Render instanced fish ----------
    function renderMeshes() {
      for (let i = 0; i < N; i++) {
        const p = P[i];
        const dir = V[i].clone().normalize();
        if (dir.lengthSq() < 1e-8) dir.set(0, 1, 0);

        // ConeGeometry points +Y, so rotate +Y -> velocity direction
        tmp.quat.setFromUnitVectors(tmp.up, dir);

        const fish = fishMeshes[i];
fish.position.copy(p);
fish.quaternion.copy(tmp.quat);

// Tail thrust + glow from forward acceleration (no oscillation)
const tail = fishTails[i];

// Forward thrust: only positive (accelerating forward)
const f = aForwardSm[i];
const fPos = Math.max(0, f);

// Map forward accel to 0..1
const fCap = 2.0; // more sensitive cap (units/s^2)
const thrust = Math.min(fPos, fCap) / fCap;

// Tail length and glow (StandardMaterial)
tail.scale.set(1, 0.75 + 2.2 * thrust, 1);
tail.material.emissiveIntensity = 0.35 + 4.0 * thrust;

// Strong banking indicator from lateral acceleration (amplified)
const lat = aLateralSm[i];
const latCap = 2.5; // more sensitive cap
const latNorm = Math.max(-latCap, Math.min(latCap, lat)) / latCap;

// Visible bank angle (radians). Increase gain for clarity.
const bankMax = 1.05; // stronger indicator (~60 degrees)
const bank = -latNorm * bankMax;

// Apply bank around forward axis (local +Y after alignment)
fish.rotateY(bank);
      }
    }


    // ---------- Resize ----------
    addEventListener("resize", () => {
      renderer.setSize(window.innerWidth, window.innerHeight);
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
    });

    // ---------- Simple touch drag to orbit camera ----------
    let dragging = false;
    let lastX = 0, lastY = 0;
    // Start camera straight on Z axis (front view)
    let yaw = 1.5;
    let pitch = 0; // 0 = XY plane straight on

    const camRadius = 22;

    function updateCamera() {
      pitch = clamp(pitch, -0.2, 1.2);
      const x = Math.cos(yaw) * Math.cos(pitch) * camRadius;
      const z = Math.sin(yaw) * Math.cos(pitch) * camRadius;
      const y = Math.sin(pitch) * camRadius;
      camera.position.set(x, y, z);
      camera.lookAt(0, 0, 0);
    }
    updateCamera();

    renderer.domElement.addEventListener("pointerdown", (e) => {
      dragging = true; lastX = e.clientX; lastY = e.clientY;
      renderer.domElement.setPointerCapture(e.pointerId);
    });
    renderer.domElement.addEventListener("pointermove", (e) => {
      if (!dragging) return;
      const dx = e.clientX - lastX;
      const dy = e.clientY - lastY;
      lastX = e.clientX; lastY = e.clientY;
      yaw -= dx * 0.005;
      pitch -= dy * 0.005;
      updateCamera();
    });
    renderer.domElement.addEventListener("pointerup", () => dragging = false);
    renderer.domElement.addEventListener("pointercancel", () => dragging = false);

    // ---------- Main loop ----------
    init();
    applyDensity();
    applySoloIndependence();

    let lastT = performance.now();
    function loop(t) {
      const dt = (t - lastT) / 1000;
      lastT = t;

      animateLights(t);

      step(dt);
      renderMeshes();

      renderer.render(scene, camera);
      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);
  </script>
</body>

</html>